/* Copyright (c) 2015-2020 ARM Limited
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef BLE_CLIAPP_CLICOMMAND_BASECOMMAND_H_
#define BLE_CLIAPP_CLICOMMAND_BASECOMMAND_H_

#include "Command.h"

/**
 * @brief Base class for Command declaration. It allows a user to declare 
 * commands like a class.
 * @details In this class and its descendant, members of the Command class are 
 * represented as static member functions. 
 * To override a function of the BaseCommand, descendant just have to redefine 
 * the static member function to override. 
 * 
 * To translate BaseCommand and classes into Command instances, a c++ template 
 * generator class is used: CommandGenerator<T>::command is the runtime Command
 * instance of the class T.
 * 
 * @code
 * 
 * struct MyCommand : public BaseCommand { 
 *    // name of the Command; mandatory
 *    static const char* name() { "my_command"; }
 *    
 *    // override the help 
 *    static const char* help() { "Help for my command"; }
 * 
 *    // other overrides if applicable 
 *    
 *    // handler of the command; mandatory
 *    static void handler(const CommandArgs& args, const CommandResponsePtr& res) { 
 *      response->success();
 *    }
 * };
 * 
 * // Access to the command 
 * Command& myCommand = CommandGenerator<MyCommand>::command;
 * @endcode
 */
struct BaseCommand {
    /**
     * @brief Returns the name of the command. This function has to be 
     * provided by classes inheriting from BaseCommand. Failing to do so will 
     * result in a linker error.
     * @see Command::name
     */
    static const char* name();

    /**
     * @brief Return the help associated with this command. The default 
     * implementation returns an empty string.
     * @see Command::help
     */
    static const char* help();

    /**
     * @brief Description of the command arguments. The default implementation 
     * returns an empty array.
     * @see Command::argsdescription
     */
    static ConstArray<CommandArgDescription> argsDescription();

    /**
     * @brief Description of the CommandResult. The default implementation 
     * returns an empty array.
     * @see Command::resultsDescription
     */
    static ConstArray<CommandArgDescription> resultDescription();

    /**
     * @brief Returns the maximum number of arguments allowed by this command. 
     * The default implementation returns the number of arguments described in 
     * T::argsDescription. 
     * @see Command::maximumArgsRequired
     */
    template<typename T>
    static std::size_t maximumArgsRequired() {
        return T::argsDescription().count();
    }

    /**
     * @brief Handler of the command. This function has to be 
     * provided by classes inheriting from BaseCommand. Failing to do so will 
     * result in a linker error.
     * @see Command::handler
     * @note The signature is not fixed for the implementation. If the  command 
     * is accessed via CommandGenerator<T>::command and the arguments can be 
     * deserialized via a fromString function then it become possible to let the 
     * system handle the deserialization process: 
     * 
     * @code 
     * 
     * bool fromString(const char* str, uint32_t result);
     * 
     * struct AddInteger { 
     * 
     * // arguments deserialization and verification is generated by the system.
     * static void handler(uint32_t lhs, uint32_t rhs, const CommandresponsePtr& response) {
     *  return response->success(lhs + rhs);
     * }
     * 
     * }; 
     * 
     * @endcode
     */
    static void handler(const CommandArgs& args, const CommandResponsePtr& res);
};

#endif //BLE_CLIAPP_CLICOMMAND_BASECOMMAND_H_
